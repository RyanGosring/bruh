************
Other topics
************

This section describes some details of dune for advanced users.

META file generation
====================

Dune uses ``META`` files from the `findlib library
manager <http://projects.camlcity.org/projects/findlib.html>`__ in order
to interoperate with the rest of the world when installing libraries. It
is able to generate them automatically. However, for the rare cases
where you would need a specific ``META`` file, or to ease the transition
of a project to dune, it is allowed to write/generate a specific
one.

In order to do that, write or setup a rule to generate a
``META.<package>.template`` file in the same directory as the
``<package>.opam`` file. Dune will generate a ``META.<package>``
file from the ``META.<package>.template`` file by replacing lines of
the form ``# DUNE_GEN`` by the contents of the ``META`` it would
normally generate.

For instance if you want to extend the ``META`` file generated by
dune you can write the following ``META.foo.template`` file:

.. code::

   # DUNE_GEN
   blah = "..."

Findlib integration and limitations
===================================

Dune uses ``META`` files to support external libraries. However, it
doesn't export the full power of findlib to the user, and especially
it doesn't let the user specify *predicates*.

The reason for this limitation is that so far they haven't been
needed, and adding full support for them would complicate things quite
a lot. In particular, complex ``META`` files are often hand-written and
the various features they offer are only available once the package is
installed, which goes against the root ideas dune is built on.

In practice, dune interprets ``META`` files assuming the following
set of predicates:

- ``mt``: what this means is that using a library that can be used
  with or without threads with dune will force the threaded
  version

- ``mt_posix``: forces the use of posix threads rather than VM
  threads. VM threads are deprecated and are likely to go away soon

- ``ppx_driver``: when a library acts differently depending on whether
  it is linked as part of a driver or meant to add a ``-ppx`` argument
  to the compiler, choose the former behavior

Dynamic loading of packages
===========================

Dune supports the ``findlib.dynload`` package from `findlib
<http://projects.camlcity.org/projects/findlib.html>`_ that allows to
dynamically load packages and their dependencies (using OCaml Dynlink module).
So adding the ability for an application to have plugins just requires to add
``findlib.dynload`` to the set of library dependencies:

.. code:: scheme

    (library
      (name mytool)
      (public_name mytool)
      (modules ...)
    )

    (executable
      (name main)
      (public_name mytool)
      (libraries mytool findlib.dynload)
      (modules ...)
    )


Then you could use in your application ``Fl_dynload.load_packages l``
that will load the list ``l`` of packages. The packages are loaded
only once. So trying to load a package statically linked does nothing.

A plugin creator just need to link to your library:

.. code:: scheme

    (library
      (name mytool_plugin_a)
      (public_name mytool-plugin-a)
      (libraries mytool)
    )

By choosing some naming convention, for example all the plugins of
``mytool`` should start with ``mytool-plugin-``. You can automatically
load all the plugins installed for your tool by listing the existing packages:

.. code:: ocaml

    let () = Findlib.init ()
    let () =
      let pkgs = Fl_package_base.list_packages () in
      let pkgs =
        List.filter
          (fun pkg -> 14 <= String.length pkg && String.sub pkg 0 14 = "mytool-plugin-")
          pkgs
      in
      Fl_dynload.load_packages pkgs

.. _advanced-cross-compilation:

Cross Compilation
=================

Dune allows for cross compilation by defining build contexts with
multiple targets. Targets are specified by adding a ``targets`` field
to the definition of a build context.

``targets`` takes a list of target name. It can be either:

- ``native`` which means using the native tools that can build
  binaries that run on the machine doing the build

- the name of an alternative toolchain

Note that at the moment, there is no official support for
cross-compilation in OCaml. Dune supports the opam-cross-x
repositories from the `ocaml-cross organization on github
<https://github.com/ocaml-cross/>`_, such as:

- `opam-cross-windows <https://github.com/ocaml-cross/opam-cross-windows>`_
- `opam-cross-android <https://github.com/ocaml-cross/opam-cross-android>`_
- `opam-cross-ios <https://github.com/ocaml-cross/opam-cross-ios>`_

In particular:

- to build Windows binaries using opam-cross-windows, write ``windows``
  in the list of targets
- to build Android binaries using opam-cross-android, write
  ``android`` in the list of targets
- to build IOS binaries using opam-cross-ios, write ``ios`` in the
  list of targets

For example, the following workspace file defines three different
targets for the ``default`` build context:

.. code:: scheme

    (context (default (targets (native windows android))))

This configuration defines three build contexts:

- ``default``
- ``default.windows``
- ``default.android``

Note that the ``native`` target is always implicitly added when not
present. However, when implicitly added ``dune build @install``
will skip this context, i.e. ``default`` will only be used for
building executables needed by the other contexts.

With such a setup, calling ``dune build @install`` will build all
the packages three times.

Note that instead of writing a ``dune-workspace`` file, you can also
use the ``-x`` command line option. Passing ``-x foo`` to ``dune``
without having a ``dune-workspace`` file is the same as writing the
following ``dune-workspace`` file:

.. code:: scheme

   (context (default (targets (foo))))

If you have a ``dune-workspace`` and pass a ``-x foo`` option,
``foo`` will be added as target of all context stanzas.

How does it work?
-----------------

In such a setup, binaries that need to be built and executed in the
``default.windows`` or ``default.android`` contexts as part of the
build, will no longer be executed. Instead, all the binaries that will
be executed will come from the ``default`` context. One consequence of
this is that all preprocessing (ppx or otherwise) will be done using
binaries built in the ``default`` context.

To clarify this with an example, let's assume that you have the following
``src/dune`` file:

.. code:: scheme

    (executable (name foo))
    (rule (with-stdout-to blah (run ./foo.exe)))

When building ``_build/default/src/blah``, dune will resolve ``./foo.exe`` to
``_build/default/src/foo.exe`` as expected. However, for
``_build/default.windows/src/blah`` dune will resolve ``./foo.exe`` to
``_build/default/src/foo.exe``

Assuming that the right packages are installed or that your workspace
has no external dependencies, dune will be able to cross-compile a
given package without doing anything special.

Some packages might still have to be updated to support cross-compilation. For
instance if the ``foo.exe`` program in the previous example was using
``Sys.os_type``, it should instead take it as a command line argument:

.. code:: scheme

  (rule (with-stdout-to blah (run ./foo.exe -os-type %{os_type})))

Classical ppx
=============

*classical ppx* refers to running ppx using the -ppx compiler option, which is
composed using Findlib. Even though this is useful to run some (usually old)
ppx's which don't support drivers, dune does not support preprocessing with
ppx this way. but a workaround exists using the `ppxfind
<https://github.com/diml/ppxfind>`_ tool.

Profiling dune
==============

If ``--trace-file FILE`` is passed, dune will write detailed data about internal
operations, such as the timing of commands that are run by dune.

The format is compatible with `Catapult trace-viewer`_. In particular, these
files can be loaded into Chromium's ``chrome://tracing``. Note that the exact
format is subject to change between versions.

.. _Catapult trace-viewer: https://github.com/catapult-project/catapult/blob/master/tracing/README.md

.. _implicit-transitive-deps:

Implicit transitive deps
========================

By default, dune allows transitive dependencies of dependencies to be used
directly when compiling OCaml. However, this setting can be controlled per
project. It can be disabled by adding the ``(implicit_transitive_deps false)``
to the ``dune-project`` file.

Once this setting is added, all dependencies that are directly used by a library
or an executable must be directly added in the ``libraries`` field. We recommend
users to experiment with this mode and report any problems. The goal is to make
this the default mode eventually.

Note that you must use ``threads.posix`` instead of ``threads`` when using this
mode. This is not an important limitation as ``threads.vm`` are deprecated
anyways.

.. _wrapped-executables:

Name mangling of executables
============================

Executables are made of compilation units whose names may collide with the
compilation units of libraries. To avoid this possibility, dune prefixes these
compilation unit names with ``Dune__exe__``. This is entirely transparent to
users except for when such executables are debugged. In which case the mangled
names will be visible in the debugger.

Starting from dune 1.11, the ``(wrapped_executables <bool>)`` option is
available to turn on/off name mangling for executables on a per project basis.

Starting from dune 2.0, dune mangles compilation units of executables by
default. However, this can still be turned off using ``(wrapped_executables
false)``

.. _explicit-js-mode:

Explicit JS mode
================

By default, Javascript targets are defined for every bytecode executable that
dune knows about. This is not very precise and does not interact well with the
``@all`` alias (eg, the ``@all`` alias will try to build JS targets
corresponding to every ``test`` stanza). In order to better control the
compilation of JS targets, this behaviour can be turned off by using
``(explicit_js_mode)`` in the ``dune-project`` file.

When explicit JS mode is enabled, an explicit ``js`` mode needs to be
added to the ``(modes ...)`` field of executables in order to trigger
JS compilation. Explicit JS targets declared like this will be
attached to the ``@all`` alias.

Starting from dune 2.0 this new behaviour will be the default and JS compilation
of binaries will need to be explicitly declared.

.. _dialects-main:

Dialects
========

A dialect is an alternative frontend to OCaml (such as ReasonML). It is
described by a pair of file extensions, one corresponding to interfaces and one
to implementations.

The extensions are unique among all dialects of a given project, so that a given
extension can be mapped back to the corresponding dialect.

A dialect can use the standard OCaml syntax or it can specify an action to
convert from a custom syntax to a binary OCaml abstract syntax tree.

Similarly, a dialect can specify a custom formatter to implement the ``@fmt``
alias, see :ref:`formatting-main`.

When not using a custom syntax or formatting action, a dialect is nothing but a
way to specify custom file extensions for OCaml code.

.. _ocaml-syntax:

OCaml syntax
============

If a ``dune`` file starts with ``(* -*- tuareg -*- *)``, then it is
interpreted as an OCaml script that generates the ``dune`` file as described
in the rest of this section. The code in the script will have access to a
`Jbuild_plugin
<https://github.com/ocaml/dune/blob/master/plugin/jbuild_plugin.mli>`__
module containing details about the build context it is executed in.

The OCaml syntax gives you an escape hatch for when the S-expression
syntax is not enough. It is not clear whether the OCaml syntax will be
supported in the long term as it doesn't work well with incremental
builds. It is possible that it will be replaced by just an ``include``
stanza where one can include a generated file.

Consequently **you must not** build complex systems based on it.

Dealing with foreign libraries
==============================

The OCaml programming language allows to interface libraries written
in foreign languages such as C. This section explains how to do this
with Dune. Note that it does not cover how to write the C stubs
themselves, this is covered by the
`OCaml manual <https://caml.inria.fr/pub/docs/manual-ocaml/intfc.html>`_

More precisely, this section covers:
- how to add C/C++ stubs to an OCaml library
- how to pass specific compilation flags for compiling the stubs
- how to build a library with a foreign build system

Note that in general Dune has limited support for building source
files written in foreign languages. This support is suitable for most
OCaml projects containing C stubs, but is too limited for building
complex libraries written in C or other languages. For such cases,
Dune allows to integrate a foreign build system into a normal Dune
build.

Adding C/C++ stubs to an OCaml library
--------------------------------------

To add C stubs to an OCaml library, simply list the C files without
the ``.c`` extension via the ``c_names`` field of the :ref:`library`
stanza. For instance:

.. code:: scheme

          (library
           (name mylib)
           (c_names file1 file2))

Similarly, you can add C++ stubs to an OCaml library by listing them
without the ``.cpp`` extension via the ``cxx_names`` field.

Dune is currently not flexible regarding the extension of the C/C++
source files. They have to be ``.c`` and ``.cpp``. If you have source
files that that do not follow this extension and you want to build
them with Dune, you need to rename them first. Alternatively, you can
use the :ref:`foreign build sandboxing <foreign-sandboxing>` method
described bellow.

Header files
^^^^^^^^^^^^

C/C++ source files may include header files in the same directory as
the C/C++ source files or in the same directory group when using
:ref:`include_subdirs`.

The header files must have the ``.h`` extension.

Installing header files
^^^^^^^^^^^^^^^^^^^^^^^

It is sometimes desirable to install header files with the
library. For that you have two choices: install them explicitly with
an :ref:`install` stanza or use the ``install_c_headers`` field of the
:ref:`library` stanza. This field takes a list of header files names
without the ``.h`` extension. When a library install header files,
these are made visible to users of the library via the include search
path.

.. _foreign-sandboxing:

Foreign build sandboxing
------------------------

When the build of a C library is too complicated to express in the
Dune language, it is possible to simply *sandbox* a foreign
build. Note that this method can be used to build other things, not
just C libraries.

To do that, follow the following procedure:

- put all the foreign code in a sub-directory
- tell Dune not to interpret configuration files in this directory via an
  :ref:`data_only_dirs <dune-data_only_dirs>` stanza
- write a custom rule that:

  - depend on this directory recursively via :ref:`source_tree <source_tree>`
  - invoke the external build system
  - copy the C archive files (``.a``, ``.so``, ...) in main library
    directory with a specific names (see bellow)
- *attach* the C archive files to an OCaml library via the
  :ref:`self_build_stubs_archive <self_build_stubs_archive>` field

For instance, let's assume that you want to build a C library
``libfoo`` using ``libfoo``'s own build system and attach it to an
OCaml library called ``foo``.

The first step is to put the sources of ``libfoo`` in your project,
for instance in ``src/libfoo``. Then tell dune to consider
``src/libfoo`` as raw data by writing the following in ``src/dune``:

.. code:: scheme

          (data_only_dirs libfoo)

The next step is to setup the rule to build ``libfoo``. For this,
writing the following code ``src/dune``:

.. code:: scheme

          (rule
           (deps (source_tree libfoo))
           (targets libfoo_stubs.a dllfoo_stubs.so)
           (action (progn
                    (chdir libfoo (run make)))
                    (copy libfoo/libfoo.a libfoo_stubs.a)
                    (copy libfoo/libfoo.so dllfoo_stubs.so)))

Note that the rule copies the files to ``libfoo_stubs.a`` and
``dllfoo_stubs.so``. It is important that the files produced are
named ``lib<ocaml-lib-name>_stubs.a`` and
``dll<ocaml-lib-name>_stubs.so``.

The last step is to attach these archives to an OCaml library as
follows:

.. code:: scheme

          (library
           (name bar)
           (self_build_stubs_archive foo))

Then, whenever you use the ``bar`` library, you will also be able to
use C functions from ``libfoo``.

Limitations
-----------

When using the sandboxing method, the following limitations apply:

- the build of the foreign code will be sequential
- the build of the foreign code won't be incremental

both these points could be improved. If you are interested in helping
make this happen, please let the Dune team know and someone will guide
you.

Real example
------------

The `re2 project <https://github.com/janestreet/re2>`_ uses this
method to build the re2 C library. You can look at the file
``re2/src/re2_c/dune`` in this project to see a full working
example.

.. _coq-main:

Coq
===

Dune is also able to build Coq developments. A Coq project is a mix of
Coq ``.v`` files and (optionally) OCaml libraries linking to the Coq
API (in which case we say the project is a *Coq plugin*). To enable
Coq support in a dune project, the language version should be selected
in the ``dune-project`` file. For example:

.. code:: scheme

    (using coq 0.1)

This will enable support for the ``coq.theory`` stanza in the current project. If the
language version is absent, dune will automatically add this line with the
latest Coq version to the project file once a ``(coq.theory ...)`` stanza is used anywhere.

Basic Usage
-----------

The basic form for defining Coq libraries is very similar to the OCaml form:

.. code:: scheme

    (coq.theory
     (name <module_prefix>)
     (public_name <package.lib_name>)
     (synopsis <text>)
     (modules <ordered_set_lang>)
     (libraries <ocaml_libraries>)
     (flags <coq_flags>))

The stanza will build all `.v` files on the given directory. The semantics of fields is:

- ``<module_prefix>>`` will be used as the default Coq library prefix ``-R``,
- the ``modules`` field does allow to constraint the set of modules
  included in the library, similarly to its OCaml counterpart,
- ``public_name`` will make Dune generate install rules for the `.vo`
  files; files will be installed in
  ``lib/coq/user-contrib/<module_prefix>``, as customary in the
  make-based Coq package eco-system. For compatibility, we also installs the `.cmxs`
  files appearing in `<ocaml-librarie>` under the `user-contrib` prefix.
- ``<coq_flags>`` will be passed to ``coqc``,
- the path to installed locations of ``<ocaml_libraries>`` will be passed to
  ``coqdep`` and ``coqc`` using Coq's ``-I`` flag; this allows for a Coq
  library to depend on a ML plugin.

Preprocessing with ``coqpp``
----------------------------

Coq plugin writers usually need to write ``.mlg`` files to extend Coq
grammar. Such files are pre-processed with `coqpp`; to help plugin
writers avoid boilerplate we provide a `(coqpp ...)` stanza:

.. code:: scheme

    (coq.pp (modules <mlg_list>))

which for each ``g_mod`` in ``<mlg_list>`` is equivalent to:

.. code:: scheme

    (rule
     (targets g_mod.ml)
     (deps (:mlg-file g_mod.mlg))
     (action (run coqpp %{mlg-file})))

Recursive Qualification of Modules
----------------------------------

If you add:

.. code:: scheme

    (include_subdirs qualified)

to a ``dune`` file, Dune will to consider that all the modules in
their directory and sub-directories, adding a prefix to the module
name in the usual Coq style for sub-directories. For example, file ``A/b/C.v`` will be module ``A.b.C``.

Limitations
-----------

- composition and scoping of Coq libraries is still not possible. For now, libraries are located using Coq's built-in library management,
- .v always depend on the native version of a plugin,
- a ``foo.mlpack`` file must the present for locally defined plugins to work, this is a limitation of coqdep,

.. _menhir-main:

Menhir
======

To use menhir in a dune project, the language version should be selected in the
``dune-project`` file. For example:

.. code:: scheme

  (using menhir 2.0)

This will enable support for menhir stanzas in the current project. If the
language version is absent, dune will automatically add this line with the
latest menhir version to the project file once a menhir stanza is used anywhere.

Basic usage
-----------

The basic form for defining menhir_ parsers (analogous to ocamlyacc) is:

.. code:: scheme

    (menhir
     (modules <parser1> <parser2> ...))

Modular menhir
--------------

Modular parsers can be defined by adding a ``merge_into`` field. This correspond
to the ``--base`` command line option of ``menhir``. With this option, a single
parser named ``base_name`` is generated.

.. code:: scheme

    (menhir
     (merge_into <base_name>)
     (modules <parser1> <parser2> ...))

Flags
-----

Extra flags can be passed to menhir using the ``flags`` flag:

.. code:: scheme

    (menhir
     (flags <option1> <option2> ...)
     (modules <parser1> <parser2> ...))

``--infer`` mode
----------------

Menhir language 2.0 automatically enables using menhir with type inference. This
ability can also be manually controlled with the ``infer`` field manually.

.. code:: scheme

  (menhir
    (infer false)
    (modules <parser1> <parser2> ...))

cmly targets
------------

Menhir supports writing the grammar and automaton to ``.cmly`` file. Therefore,
if this is flag is passed to menhir, dune will know to introduce a ``.cmly``
target for the module.

.. _menhir: https://gitlab.inria.fr/fpottier/menhir

js_of_ocaml
===========

js_of_ocaml_ is a compiler from OCaml to JavaScript. The compiler works by
translating OCaml bytecode to JS files. The compiler can be installed with
opam:

.. code:: bash

   $ opam install js_of_ocaml-compiler

Compiling to JS
---------------

Dune has full support building js_of_ocaml libraries and executables transparently.
There's no need to customize or enable anything to compile ocaml
libraries/executables to JS.

To build a JS executable, just define an executable as you would normally.
Consider this example:

.. code:: bash

   echo 'print_endline "hello from js"' > foo.ml

With the following dune file:

.. code:: scheme

  (executable (name foo))

And then request the ``.js`` target:

.. code:: bash

   $ dune build ./foo.bc.js
   $ node _build/default/foo.bc.js
   hello from js

Similar targets are created for libraries, but we recommend sticking to the
executable targets.

.. _dune-jsoo-field:

``js_of_ocaml`` field
---------------------

In ``library`` and ``executables`` stanzas, you can specify js_of_ocaml options
using ``(js_of_ocaml (<js_of_ocaml-options>))``.

``<js_of_ocaml-options>`` are all optional:

- ``(flags <flags>)`` to specify flags passed to ``js_of_ocaml``. This field
  supports ``(:include ...)`` forms

- ``(javascript_files (<files-list>))`` to specify ``js_of_ocaml`` JavaScript
  runtime files.

``<flags>`` is specified in the :ref:`ordered-set-language`.

The default value for ``(flags ...)`` depends on the selected build profile. The
build profile ``dev`` (the default) will enable sourcemap and the pretty
JavaScript output.

Separate Compilation
--------------------

Dune supports two modes of compilation

- Direct compilation of a bytecode program to JavaScript. This mode allows
  js_of_ocaml to perform whole program deadcode elimination and whole program
  inlining.

- Separate compilation, where compilation units are compiled to JavaScript
  separately and then linked together. This mode is useful during development as
  it builds more quickly.

The separate compilation mode will be selected when the build profile is
``dev``, which is the default. There is currently no other way to control this
behaviour.

.. _js_of_ocaml: http://ocsigen.org/js_of_ocaml/

Virtual Libraries & Variants
============================

Virtual libraries correspond to dune's ability to compile parameterized
libraries and delay the selection of concrete implementations until linking an
executable.

The feature introduces two kinds of libraries: virtual and implementations. A
*virtual library* corresponds to an interface (although it may contain partial
implementation). An *implementation* of a virtual library fills in all
unimplemented modules in the virtual library.

The benefit of this partition is that other libraries may depend and compile
against the virtual library and only select concrete implementations for these
virtual libraries when linking executables. An example where this might be
useful would be a virtual, cross platform, ``clock`` library. This library would
have ``clock.unix`` and ``clock.win`` implementations. Executable using
``clock`` or libraries that use ``clock`` would conditionally select one of the
implementations, depending on the target platform.

Virtual Library
---------------

To define a virtual library, a ``virtual_modules`` field must be added to an
ordinary library stanza and the version of the dune language must be at least
1.5. This field defines modules for which only an interface would be present
(mli only):

.. code:: scheme

   (library
    (name clock)
    ;; clock.mli must be present, but clock.ml must not be
    (virtual_modules clock))

Apart from this field, the virtual library is defined just like a normal library
and may use all the other fields. A virtual library may include other modules
(with or without implementations), which is why it's not a pure "interface"
library.

Implementation
--------------

An implementation for a library is defined as:

.. code:: scheme

   (library
    (name clock_unix)
    ;; clock.ml must be present, but clock.mli must not be
    (implements clock))

The ``name`` field is slightly different for an implementation than it is for a
normal library. The ``name`` is just an internal name to refer to the
implementation, it does not correspond to any particular module like it does in
the virtual library.

Other libraries may then depend on the virtual library as if it was a regular
library:

.. code:: scheme

   (library
    (name calendar)
    (libraries clock))

But when it comes to creating an executable, we must now select a valid
implementation for every virtual library that we've used:

.. code:: scheme

   (executable
    (name birthday-reminder)
    (libraries
     clock_unix ;; leaving this dependency will make dune loudly complain
     calendar))

.. _dune-variants:

Variants
--------

This feature is still under development and may change with new dune
releases. You need to write ``(using library_variants 0.2)`` in your
``dune-project`` file to unlock it.

When building a binary, implementations can be selected using a set of variants
rather than individually specifying implementations.

An example where this is useful is providing JavaScript implementation. It would
be tedious to select the JS implementation for every single virtual library.
Instead, such implementations could select a ``js`` variant. Here's the syntax:

.. code:: scheme

   (executable
    (name foo)
    (libraries time filesystem)
    (variants js))

An implementation can specify which variant it corresponds to using the
``variant`` option. Say for example that ``time`` is a virtual library. Its JS
implementation would have the following configuration:

.. code:: scheme

   (library
    (name time-js)
    (implements time)
    (variant js))

The list of available variants is computed while building the virtual library.
This means only variant implementations that are part of the same project are
implicitely taken into account. It's possible to declare an external
implementation by using the `external_variant` stanza in the virtual library
scope.

.. code:: scheme

   (external_variant
    (variant foo)
    (implementation lib-foo)
    (virtual_library vlib))

This will add `lib-foo` to the list of known implementations of `vlib`.

Default implementation
----------------------

This feature is also guarded by ``(using library_variants ...)``.

A virtual library may select a default implementation, which is enabled after
variant resolution, if no suitable implementation has been found.

.. code:: scheme

   (library
    (name time)
    (virtual_modules time)
    (default_implementation time-js))

Limitations
-----------

The current implementation of virtual libraries suffers from a few limitations.
Some of these are temporary.

* It is not possible to link more than one implementation for the same
  virtual library in one executable.

* It is not possible for implementations to introduce new public modules. That
  is, modules that aren't a part of the virtual library's cmi. Consequently, a
  module in an implementation either implements a virtual module or is private.

* It's not possible to load virtual virtual libraries into utop. As a result,
  any directory that contains a virtual library will not work with ``$ dune
  utop``. This is an essential limitation, but it would be best to somehow skip
  these libraries or provide an implementation for them when loading a toplevel.

* Virtual libraries must be defined using dune. It's not possible for dune to
  implement virtual libraries created outside of dune. On the other hand,
  virtual libraries and implementations defined using dune should be usable with
  findlib based build systems.

* It is not possible for a library to be both virtual and implement another
  library. This isn't very useful, but technically, it could be used to create
  partial implementations. It is possible to lift this restriction if there's
  enough demand for this.

Package version
===============

Note that dune will try to determine the version number of packages
defined in the workspace. While dune itself makes no use of version
numbers, it can be use by external tools such as
`ocamlfind <http://projects.camlcity.org/projects/findlib.html>`__.

Dune determines the version of a package by trying the following
methods in order:

- it looks in the ``<package>.opam`` file for a ``version`` variable
- it looks for a ``<package>.version`` file in the same directory and
  reads the first line
- it looks for the version specified in the ``dune-project`` if present
- it looks for a ``version`` file and reads the first line
- it looks for a ``VERSION`` file and reads the first line

``<package>.version``, ``version`` and ``VERSION`` files may be
generated.

If the version can't be determined, dune just won't assign one.

Odig conventions
================

Dune follows the `odig <http://erratique.ch/software/odig>`__
conventions and automatically installs any README\*, CHANGE\*, HISTORY\*
and LICENSE\* files in the same directory as the ``<package>.opam`` file
to a location where odig will find them.

Note that this includes files present in the source tree as well as
generated files. So for instance a changelog generated by a user rule
will be automatically installed as well.
