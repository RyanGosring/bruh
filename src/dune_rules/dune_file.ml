open Import

type t =
  { dir : Path.Source.t
  ; project : Dune_project.t
  ; stanzas : Stanza.t list
  }

let dir t = t.dir
let stanzas t = t.stanzas
let set_stanzas t stanzas = { t with stanzas }
let project t = t.project

let is_promoted_rule =
  let is_promoted_mode version = function
    | Rule.Mode.Promote { only = None; lifetime; _ } ->
      if version >= (3, 5)
      then (
        match lifetime with
        | Unlimited -> true
        | Until_clean -> false)
      else true
    | _ -> false
  in
  fun version rule ->
    match Stanza.repr rule with
    | Rule_conf.T { mode; _ } | Menhir_stanza.T { mode; _ } ->
      is_promoted_mode version mode
    | _ -> false
;;

(* XXX this is needed for evaluating includes generated by dune files written
   in OCaml syntax.*)
let rec parse_file_includes ~stanza_parser ~context sexps =
  List.concat_map sexps ~f:(Dune_lang.Decoder.parse stanza_parser Univ_map.empty)
  |> Memo.List.concat_map ~f:(fun stanza ->
    match Stanza.repr stanza with
    | Stanzas.Include.T (loc, fn) ->
      let open Memo.O in
      let* sexps, context = Include_stanza.load_sexps ~context (loc, fn) in
      parse_file_includes ~stanza_parser ~context sexps
    | _ -> Memo.return [ stanza ])
;;

let parse ~file ~dir (project : Dune_project.t) sexps =
  let stanza_parser = Dune_project.stanza_parser project in
  let warnings = Warning_emit.Bag.create () in
  let stanza_parser = Warning_emit.Bag.set warnings stanza_parser in
  let open Memo.O in
  let* stanzas =
    let context =
      Include_stanza.in_file
      @@
      match file with
      | Some f -> f
      | None ->
        (* TODO this is wrong *)
        Path.Source.relative dir Dune_file0.fname
    in
    parse_file_includes ~stanza_parser ~context sexps
  in
  let (_ : bool) =
    List.fold_left stanzas ~init:false ~f:(fun env stanza ->
      match Stanza.repr stanza with
      | Dune_env.T e ->
        if env
        then
          User_error.raise
            ~loc:e.loc
            [ Pp.text "The 'env' stanza cannot appear more than once" ]
        else true
      | _ -> env)
  in
  let+ () = Warning_emit.Bag.emit_all warnings in
  stanzas
;;

let parse sexps ~dir ~file ~project =
  let open Memo.O in
  let+ stanzas = parse ~file ~dir project sexps in
  let stanzas =
    if !Clflags.ignore_promoted_rules
    then (
      let version = Dune_project.dune_version project in
      List.filter stanzas ~f:(fun s -> not (is_promoted_rule version s)))
    else stanzas
  in
  { dir; project; stanzas }
;;

module Make_fold (M : Monad.S) = struct
  open M.O

  let rec fold_stanzas l ~init ~f =
    match l with
    | [] -> M.return init
    | t :: l -> inner_fold t t.stanzas l ~init ~f

  and inner_fold t inner_list l ~init ~f =
    match inner_list with
    | [] -> fold_stanzas l ~init ~f
    | x :: inner_list ->
      let* init = f t x init in
      inner_fold t inner_list l ~init ~f
  ;;
end

module Memo_fold = Make_fold (Memo)
module Id_fold = Make_fold (Monad.Id)

let fold_stanzas t ~init ~f = Id_fold.fold_stanzas t ~init ~f

let equal t { dir; project; stanzas } =
  Path.Source.equal t.dir dir
  && Dune_project.equal t.project project
  && List.equal Stanza.equal t.stanzas stanzas
;;

let hash = Poly.hash
let to_dyn = Dyn.opaque

let find_stanzas t key =
  (* CR-rgrinberg: save a map to represent the stanzas to make this fast. *)
  List.filter_map t.stanzas ~f:(Stanza.Key.get key)
;;
