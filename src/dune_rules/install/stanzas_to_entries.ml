open Import
open Memo.O
module Library = Dune_file.Library

let lib_ppxs sctx ~scope ~(lib : Dune_file.Library.t) =
  match lib.kind with
  | Normal | Ppx_deriver _ -> Memo.return []
  | Ppx_rewriter _ ->
    let name = Dune_file.Library.best_name lib in
    let+ ppx_exe =
      Resolve.Memo.read_memo (Preprocessing.ppx_exe sctx ~scope name)
    in
    [ ppx_exe ]

let if_ cond l = if cond then l else []

let lib_files ~dir_contents ~dir ~lib_config lib =
  let virtual_library = Option.is_some (Lib_info.virtual_ lib) in
  let { Lib_config.ext_obj; _ } = lib_config in
  let archives = Lib_info.archives lib in
  let+ modules =
    let+ ml_sources = Dir_contents.ocaml dir_contents in
    Some (Ml_sources.modules ml_sources ~for_:(Library (Lib_info.name lib)))
  and+ foreign_archives =
    if virtual_library then
      let+ foreign_sources = Dir_contents.foreign_sources dir_contents in
      let name = Lib_info.name lib in
      let files = Foreign_sources.for_lib foreign_sources ~name in
      Foreign.Sources.object_files files ~dir ~ext_obj
    else
      Memo.return (Mode.Map.Multi.to_flat_list @@ Lib_info.foreign_archives lib)
  in
  List.concat_map
    ~f:(List.map ~f:(fun f -> (Section.Lib, f)))
    [ archives.byte
    ; archives.native
    ; foreign_archives
    ; Lib_info.eval_native_archives_exn lib ~modules
    ; Lib_info.jsoo_runtime lib
    ]
  @ List.map ~f:(fun f -> (Section.Libexec, f)) (Lib_info.plugins lib).native

let dll_files ~(modes : Mode.Dict.Set.t) ~dynlink ~(ctx : Context.t) lib =
  if_
    (modes.byte
    && Dynlink_supported.get dynlink ctx.supports_shared_libraries
    && ctx.dynamically_linked_foreign_archives)
    (Lib_info.foreign_dll_files lib)

let lib_install_files sctx ~scope ~dir_contents ~dir ~sub_dir:lib_subdir
    (lib : Library.t) =
  let loc = lib.buildable.loc in
  let ctx = Super_context.context sctx in
  let lib_config = ctx.lib_config in
  let* info = Dune_file.Library.to_lib_info lib ~dir ~lib_config in
  let make_entry =
    let in_sub_dir = function
      | None -> lib_subdir
      | Some subdir ->
        Some
          (match lib_subdir with
          | None -> subdir
          | Some lib_subdir -> Filename.concat lib_subdir subdir)
    in
    fun section ?(loc = loc) ?sub_dir ?dst fn ->
      let entry =
        Install.Entry.make section fn ~kind:`File
          ~dst:
            (let dst =
               match dst with
               | Some s -> s
               | None -> Path.Build.basename fn
             in
             let sub_dir = in_sub_dir sub_dir in
             match sub_dir with
             | None -> dst
             | Some dir -> sprintf "%s/%s" dir dst)
      in
      Install.Entry.Sourced.create ~loc entry
  in
  let lib_name = Library.best_name lib in
  let* installable_modules =
    let* ml_sources = Dir_contents.ocaml dir_contents in
    let modules = Ml_sources.modules ml_sources ~for_:(Library lib_name) in
    let+ impl = Virtual_rules.impl sctx ~lib ~scope in
    let modules = Vimpl.impl_modules impl modules in
    Modules.split_by_lib modules
  in
  let lib_src_dir = Lib_info.src_dir info in
  let sources =
    List.concat_map installable_modules.impl ~f:(fun m ->
        List.map (Module.sources m) ~f:(fun source ->
            (* We add the -gen suffix to a few files generated by dune, such
               as the alias module. *)
            let source = Path.as_in_build_dir_exn source in
            let sub_dir, dst =
              let sub_dir, dst =
                match Module.install_as m with
                | Some p ->
                  let subdir =
                    let parent = Path.Local.parent_exn p in
                    if Path.Local.is_root parent then None
                    else
                      Some (Path.Local.explode parent |> String.concat ~sep:"/")
                  in
                  (subdir, Some (Path.Local.basename p))
                | None ->
                  let dst =
                    Path.Build.basename source
                    |> String.drop_suffix ~suffix:"-gen"
                  in
                  let sub_dir =
                    let src_dir = Path.Build.parent_exn source in
                    if Path.Build.equal src_dir lib_src_dir then None
                    else
                      Path.Build.local src_dir
                      |> Path.Local.descendant
                           ~of_:(Path.Build.local lib_src_dir)
                      |> Option.map ~f:Path.Local.to_string
                  in
                  (sub_dir, dst)
              in
              (sub_dir, dst)
            in
            make_entry ?sub_dir Lib source ?dst))
  in
  let additional_deps (loc, deps) =
    let+ deps =
      let* expander = Super_context.expander sctx ~dir:lib_src_dir in
      Lib_file_deps.eval deps ~expander ~loc ~paths:(Disallow_external lib_name)
    in
    Path.Set.to_list_map deps ~f:(fun path ->
        let path = Path.as_in_build_dir_exn path in
        let sub_dir =
          let src_dir = Path.Build.parent_exn path in
          match Path.Build.equal lib_src_dir src_dir with
          | true -> None
          | false ->
            Path.Build.local src_dir
            |> Path.Local.descendant ~of_:(Path.Build.local lib_src_dir)
            |> Option.map ~f:Path.Local.to_string
        in
        make_entry ?sub_dir Lib path)
  in
  let* melange_runtime_entries = additional_deps lib.melange_runtime_deps
  and+ public_headers = additional_deps lib.public_headers in
  let { Lib_config.has_native; ext_obj; _ } = lib_config in
  let { Lib_mode.Map.ocaml = { Mode.Dict.byte; native } as ocaml; melange } =
    Dune_file.Mode_conf.Lib.Set.eval lib.modes ~has_native
  in
  let* module_files =
    let obj_dir = Lib_info.obj_dir info in
    let external_obj_dir =
      Obj_dir.convert_to_external obj_dir ~dir:(Path.build dir)
    in
    let cm_dir m cm_kind =
      let visibility = Module.visibility m in
      let dir' = Obj_dir.cm_dir external_obj_dir cm_kind visibility in
      if Path.equal (Path.build dir) dir' then None
      else Path.basename dir' |> Option.some
    in
    let virtual_library = Library.is_virtual lib in
    let if_ b (cm_kind, f) =
      if b then
        match f with
        | None -> []
        | Some f -> [ (cm_kind, f) ]
      else []
    in
    let modules =
      let common m =
        let cm_file kind = Obj_dir.Module.cm_file obj_dir m ~kind in
        let open Lib_mode.Cm_kind in
        [ if_ (native || byte) (Ocaml Cmi, cm_file (Ocaml Cmi))
        ; if_ native (Ocaml Cmx, cm_file (Ocaml Cmx))
        ; if_ (byte && virtual_library) (Ocaml Cmo, cm_file (Ocaml Cmo))
        ; if_
            (native && virtual_library)
            (Ocaml Cmx, Obj_dir.Module.o_file obj_dir m ~ext_obj)
        ; if_ melange (Melange Cmi, cm_file (Melange Cmi))
        ; if_ melange (Melange Cmj, cm_file (Melange Cmj))
        ]
        |> List.concat
      in
      let set_dir m = List.map ~f:(fun (cm_kind, p) -> (cm_dir m cm_kind, p)) in
      let+ modules_impl =
        let+ bin_annot = Super_context.bin_annot sctx ~dir in
        List.concat_map installable_modules.impl ~f:(fun m ->
            let cmt_files =
              if bin_annot then
                List.concat_map Ml_kind.all ~f:(fun ml_kind ->
                    let open Lib_mode.Cm_kind in
                    List.concat_map
                      [ (native || byte, Ocaml Cmi); (melange, Melange Cmi) ]
                      ~f:(fun (condition, kind) ->
                        if_ condition
                          ( kind
                          , Obj_dir.Module.cmt_file obj_dir m ~ml_kind
                              ~cm_kind:kind )))
              else []
            in

            common m @ cmt_files |> set_dir m)
      in
      let modules_vlib =
        List.concat_map installable_modules.vlib ~f:(fun m ->
            if Module.kind m = Virtual then [] else common m |> set_dir m)
      in
      modules_vlib @ modules_impl
    in
    modules
  in
  let* lib_files, dll_files =
    let+ lib_files = lib_files ~dir ~dir_contents ~lib_config info in
    let dll_files = dll_files ~modes:ocaml ~dynlink:lib.dynlink ~ctx info in
    (lib_files, dll_files)
  in
  let install_c_headers =
    List.rev_map lib.install_c_headers ~f:(fun (loc, base) ->
        Path.Build.relative dir (base ^ Foreign_language.header_extension)
        |> make_entry ~loc Lib)
  in
  let+ execs = lib_ppxs ctx ~scope ~lib in
  List.concat
    [ sources
    ; melange_runtime_entries
    ; List.map module_files ~f:(fun (sub_dir, file) ->
          make_entry ?sub_dir Lib file)
    ; List.map lib_files ~f:(fun (section, file) -> make_entry section file)
    ; List.map execs ~f:(make_entry Libexec)
    ; List.map dll_files ~f:(fun a ->
          let entry = Install.Entry.make ~kind:`File Stublibs a in
          Install.Entry.Sourced.create ~loc entry)
    ; install_c_headers
    ; public_headers
    ]

let keep_if expander ~scope stanza =
  let+ keep =
    let open Dune_file in
    match (stanza : Stanza.t) with
    | Library lib ->
      let* enabled_if = Expander.eval_blang expander lib.enabled_if in
      if enabled_if then
        if lib.optional then
          Lib.DB.available (Scope.libs scope) (Dune_file.Library.best_name lib)
        else Memo.return true
      else Memo.return false
    | Documentation _ -> Memo.return true
    | Install { enabled_if; _ } -> Expander.eval_blang expander enabled_if
    | Plugin _ -> Memo.return true
    | Executables ({ install_conf = Some _; _ } as exes) -> (
      Expander.eval_blang expander exes.enabled_if >>= function
      | false -> Memo.return false
      | true ->
        if not exes.optional then Memo.return true
        else
          let* compile_info =
            let dune_version =
              Scope.project scope |> Dune_project.dune_version
            in
            let+ pps =
              (* This is wrong. If the preprocessors fail to resolve,
                 we shouldn't install the binary rather than failing outright
              *)
              Preprocess.Per_module.with_instrumentation
                exes.buildable.preprocess
                ~instrumentation_backend:
                  (Lib.DB.instrumentation_backend (Scope.libs scope))
              |> Resolve.Memo.read_memo >>| Preprocess.Per_module.pps
            in
            let merlin_ident =
              Merlin_ident.for_exes ~names:(List.map ~f:snd exes.names)
            in
            Lib.DB.resolve_user_written_deps (Scope.libs scope)
              ~forbidden_libraries:[] (`Exe exes.names) exes.buildable.libraries
              ~pps ~dune_version
              ~allow_overlaps:exes.buildable.allow_overlapping_dependencies
              ~merlin_ident
          in
          let+ requires = Lib.Compile.direct_requires compile_info in
          Resolve.is_ok requires)
    | Coq_stanza.Theory.T d -> Memo.return (Option.is_some d.package)
    | _ -> Memo.return false
  in
  Option.some_if keep stanza

let is_odig_doc_file fn =
  List.exists [ "README"; "LICENSE"; "CHANGE"; "HISTORY" ] ~f:(fun prefix ->
      String.is_prefix fn ~prefix)

let stanza_to_entries ~sites ~sctx ~dir ~scope ~expander stanza =
  let* stanza_and_package =
    let+ stanza = keep_if expander stanza ~scope in
    let open Option.O in
    let* stanza = stanza in
    let+ package = Dune_file.stanza_package stanza in
    (stanza, package)
  in
  match stanza_and_package with
  | None -> Memo.return None
  | Some (stanza, package) ->
    let new_entries =
      let open Dune_file in
      match (stanza : Stanza.t) with
      | Install i | Executables { install_conf = Some i; _ } ->
        let section = i.section in
        let expand_str = Expander.No_deps.expand_str expander in
        let* files_expanded =
          Install_entry.File.to_file_bindings_expanded i.files ~expand_str ~dir
        in
        let* files =
          Memo.List.map files_expanded ~f:(fun fb ->
              let loc = File_binding.Expanded.src_loc fb in
              let src = File_binding.Expanded.src fb in
              let dst = File_binding.Expanded.dst fb in
              let+ entry =
                Install.Entry.make_with_site ~kind:`File section
                  (Sites.section_of_site sites)
                  src ?dst
              in
              Install.Entry.Sourced.create ~loc entry)
        in
        let* dirs_expanded =
          Install_entry.Dir.to_file_bindings_expanded i.dirs ~expand_str ~dir
        in
        let+ files_from_dirs =
          Memo.List.map dirs_expanded ~f:(fun fb ->
              let loc = File_binding.Expanded.src_loc fb in
              let src = File_binding.Expanded.src fb in
              let dst = File_binding.Expanded.dst fb in
              let+ entry =
                Install.Entry.make_with_site section ~kind:`Directory
                  (Sites.section_of_site sites)
                  src ?dst
              in
              Install.Entry.Sourced.create ~loc entry)
        in
        files @ files_from_dirs
      | Library lib ->
        let sub_dir = Dune_file.Library.sub_dir lib in
        let* dir_contents = Dir_contents.get sctx ~dir in
        lib_install_files sctx ~scope ~dir ~sub_dir lib ~dir_contents
      | Coq_stanza.Theory.T coqlib -> Coq_rules.install_rules ~sctx ~dir coqlib
      | Documentation d ->
        let* dc = Dir_contents.get sctx ~dir in
        let+ mlds = Dir_contents.mlds dc d in
        List.map mlds ~f:(fun mld ->
            let entry =
              Install.Entry.make ~kind:`File
                ~dst:(sprintf "odoc-pages/%s" (Path.Build.basename mld))
                Section.Doc mld
            in
            Install.Entry.Sourced.create ~loc:d.loc entry)
      | Plugin t -> Plugin_rules.install_rules ~sctx ~sites ~dir t
      | _ -> Memo.return []
    in
    let name = Package.name package in
    let+ entries = new_entries in
    Some (name, entries)

let stanzas_to_entries sctx =
  let ctx = Super_context.context sctx in
  let* stanzas = Only_packages.filtered_stanzas ctx in
  let* packages = Only_packages.get () in
  let+ init =
    Package.Name.Map_traversals.parallel_map packages
      ~f:(fun _name (pkg : Package.t) ->
        let opam_file = Package_paths.opam_file ctx pkg in
        let init =
          let file section local_file dst =
            Install.Entry.make section local_file ~kind:`File ~dst
            |> Install.Entry.Sourced.create
          in
          let deprecated_meta_and_dune_files =
            Package.Name.Map.to_list pkg.deprecated_package_names
            |> List.concat_map ~f:(fun (name, _) ->
                   let meta_file =
                     Package_paths.deprecated_meta_file ctx pkg name
                   in
                   let dune_package_file =
                     Package_paths.deprecated_dune_package_file ctx pkg name
                   in
                   let file local_file install_fn =
                     file Lib_root local_file
                       (Package.Name.to_string name ^ "/" ^ install_fn)
                   in
                   [ file meta_file Findlib.meta_fn
                   ; file dune_package_file Dune_package.fn
                   ])
          in
          let meta_file = Package_paths.meta_file ctx pkg in
          let dune_package_file = Package_paths.dune_package_file ctx pkg in
          file Lib meta_file Findlib.meta_fn
          :: file Lib dune_package_file Dune_package.fn
          ::
          (match opam_file with
          | None -> deprecated_meta_and_dune_files
          | Some opam_file ->
            file Lib opam_file "opam" :: deprecated_meta_and_dune_files)
        in
        let pkg_dir = Package.dir pkg in
        Source_tree.find_dir pkg_dir >>| function
        | None -> init
        | Some dir ->
          let pkg_dir = Path.Build.append_source ctx.build_dir pkg_dir in
          Source_tree.Dir.files dir
          |> Filename.Set.fold ~init ~f:(fun fn acc ->
                 if is_odig_doc_file fn then
                   let odig_file = Path.Build.relative pkg_dir fn in
                   let entry = Install.Entry.make Doc ~kind:`File odig_file in
                   Install.Entry.Sourced.create entry :: acc
                 else acc))
  and+ l =
    let* sites = Sites.create ctx in
    Dune_file.fold_stanzas stanzas ~init:[] ~f:(fun dune_file stanza acc ->
        let dir = Path.Build.append_source ctx.build_dir dune_file.dir in
        let named_entries =
          let* expander = Super_context.expander sctx ~dir in
          let scope = Expander.scope expander in
          stanza_to_entries ~sites ~sctx ~dir ~scope ~expander stanza
        in
        named_entries :: acc)
    |> Memo.all
  in
  List.fold_left l ~init ~f:(fun acc named_entries ->
      match named_entries with
      | None -> acc
      | Some (name, entries) -> Package.Name.Map.Multi.add_all acc name entries)
  |> Package.Name.Map.map ~f:(fun entries ->
         (* Sort entries so that the ordering in [dune-package] is independent
            of Dune's current implementation. *)
         (* jeremiedimino: later on, we group this list by section and sort
            each section. It feels like we should just do this here once and
            for all. *)
         List.sort entries
           ~compare:(fun
                      (a : Install.Entry.Sourced.t)
                      (b : Install.Entry.Sourced.t)
                    -> Install.Entry.compare Path.Build.compare a.entry b.entry))

let stanzas_to_entries =
  let memo =
    Memo.create
      ~input:(module Super_context.As_memo_key)
      "stanzas-to-entries" stanzas_to_entries
  in
  Memo.exec memo
